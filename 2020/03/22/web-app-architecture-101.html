<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Web Application Architecture 101 | Hoanh An</title><meta name="generator" content="Jekyll v3.7.4" /><meta property="og:title" content="Web Application Architecture 101" /><meta name="author" content="Hoanh An" /><meta property="og:locale" content="en_US" /><meta name="description" content="Tiers A tier is a logical separation of components in an application or service - database, backend app, user interface, messaging, caching Single tier: user interface, backend business logic, database reside in the same machine Pros: no network latency Cons: hard to maintain once is shipped Two-tier: client (user interface, business logic) &amp; server (database) Communication happens over the HTTP protocol (request-response model &amp; stateless) REST API takes advantage of the HTTP methodologies to establish communication between the client and the server Three-tier: user interface, application logic, database reside in different machines N-tier: more than 3 components involved - cache, message queues, load balancers,… Single Responsibility Principle: a component has only a single responsibility Separation of concerns: keep components separate, make them reusable Scalability Ability to withstand increased workload without sacrificing the latency Latency an be divided into 2 parts: Network latency: amount of time the network takes to send data packet from point A to B Application latency: amount of time the application takes to process a user request Type of scalability Vertical scaling/scaling up: adding more power to server Pros: not a lot of overhead on monitoring, operating and maintaining Cons: single point of failure Horizontal scaling/scaling out: adding more hardware to the existing resource pool Pros: cheaper, better fault-tolerance Cons: managing server is hard, writing distributed computing program is also challenging Common bottlenecks that hurt scalability Database latency Poor application architecture Not caching wisely Inefficient configuration and load balancing Adding business logic to the database Badly written code Common strategies to improve and test the scalability Profiling Cache wisely Use a CDN Compress data Avoid unnecessary round trips between client and sever Run load &amp; stress tests High Availability Ability to stay online despite having failures at the infrastructural level in real-time Common reasons for system failures Software crashes Hardware crashes Human error Planned downtime A common way to add more availability is to have redundancy - duplicating the components &amp; keeping them on standby to take over in case the active instances go down Monolithic &amp; Microservices Monolithic: entire application code in a single codebase Pros: simple to develop, test, deploy as everything resides in one repo Cons: Continuous deployment means re-deploying the entire application Single point of failure Hard to scale" /><meta property="og:description" content="Tiers A tier is a logical separation of components in an application or service - database, backend app, user interface, messaging, caching Single tier: user interface, backend business logic, database reside in the same machine Pros: no network latency Cons: hard to maintain once is shipped Two-tier: client (user interface, business logic) &amp; server (database) Communication happens over the HTTP protocol (request-response model &amp; stateless) REST API takes advantage of the HTTP methodologies to establish communication between the client and the server Three-tier: user interface, application logic, database reside in different machines N-tier: more than 3 components involved - cache, message queues, load balancers,… Single Responsibility Principle: a component has only a single responsibility Separation of concerns: keep components separate, make them reusable Scalability Ability to withstand increased workload without sacrificing the latency Latency an be divided into 2 parts: Network latency: amount of time the network takes to send data packet from point A to B Application latency: amount of time the application takes to process a user request Type of scalability Vertical scaling/scaling up: adding more power to server Pros: not a lot of overhead on monitoring, operating and maintaining Cons: single point of failure Horizontal scaling/scaling out: adding more hardware to the existing resource pool Pros: cheaper, better fault-tolerance Cons: managing server is hard, writing distributed computing program is also challenging Common bottlenecks that hurt scalability Database latency Poor application architecture Not caching wisely Inefficient configuration and load balancing Adding business logic to the database Badly written code Common strategies to improve and test the scalability Profiling Cache wisely Use a CDN Compress data Avoid unnecessary round trips between client and sever Run load &amp; stress tests High Availability Ability to stay online despite having failures at the infrastructural level in real-time Common reasons for system failures Software crashes Hardware crashes Human error Planned downtime A common way to add more availability is to have redundancy - duplicating the components &amp; keeping them on standby to take over in case the active instances go down Monolithic &amp; Microservices Monolithic: entire application code in a single codebase Pros: simple to develop, test, deploy as everything resides in one repo Cons: Continuous deployment means re-deploying the entire application Single point of failure Hard to scale" /><meta property="og:site_name" content="Hoanh An" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-03-22T00:00:00-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Web Application Architecture 101" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Hoanh An" /> <script type="application/ld+json"> {"url":"/2020/03/22/web-app-architecture-101","mainEntityOfPage":{"@type":"WebPage","@id":"/2020/03/22/web-app-architecture-101"},"author":{"@type":"Person","name":"Hoanh An"},"headline":"Web Application Architecture 101","dateModified":"2020-03-22T00:00:00-04:00","datePublished":"2020-03-22T00:00:00-04:00","description":"Tiers A tier is a logical separation of components in an application or service - database, backend app, user interface, messaging, caching Single tier: user interface, backend business logic, database reside in the same machine Pros: no network latency Cons: hard to maintain once is shipped Two-tier: client (user interface, business logic) &amp; server (database) Communication happens over the HTTP protocol (request-response model &amp; stateless) REST API takes advantage of the HTTP methodologies to establish communication between the client and the server Three-tier: user interface, application logic, database reside in different machines N-tier: more than 3 components involved - cache, message queues, load balancers,… Single Responsibility Principle: a component has only a single responsibility Separation of concerns: keep components separate, make them reusable Scalability Ability to withstand increased workload without sacrificing the latency Latency an be divided into 2 parts: Network latency: amount of time the network takes to send data packet from point A to B Application latency: amount of time the application takes to process a user request Type of scalability Vertical scaling/scaling up: adding more power to server Pros: not a lot of overhead on monitoring, operating and maintaining Cons: single point of failure Horizontal scaling/scaling out: adding more hardware to the existing resource pool Pros: cheaper, better fault-tolerance Cons: managing server is hard, writing distributed computing program is also challenging Common bottlenecks that hurt scalability Database latency Poor application architecture Not caching wisely Inefficient configuration and load balancing Adding business logic to the database Badly written code Common strategies to improve and test the scalability Profiling Cache wisely Use a CDN Compress data Avoid unnecessary round trips between client and sever Run load &amp; stress tests High Availability Ability to stay online despite having failures at the infrastructural level in real-time Common reasons for system failures Software crashes Hardware crashes Human error Planned downtime A common way to add more availability is to have redundancy - duplicating the components &amp; keeping them on standby to take over in case the active instances go down Monolithic &amp; Microservices Monolithic: entire application code in a single codebase Pros: simple to develop, test, deploy as everything resides in one repo Cons: Continuous deployment means re-deploying the entire application Single point of failure Hard to scale","@type":"BlogPosting","@context":"https://schema.org"}</script><link rel="shortcut icon" href="/favicon.png"><link rel="alternate" type="application/atom+xml" title="Hoanh An" href="/atom.xml"><link rel="alternate" title="Hoanh An" type="application/json" href="/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style type="text/css"> body{font-family:-apple-system,BlinkMacSystemFont,'avenir next',avenir,Noto Sans,helvetica,'helvetica neue',sans-serif}body{font-size:1rem;line-height:1.5;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility}a,a:visited{color:inherit}a:hover,a:visited:hover{color:dodgerblue}li{list-style-position:outside;margin-left:18px;margin-bottom:2px}blockquote{background:#f9f9f9;border-left:5px solid black;font-size:100%;margin:2rem 0;padding:1rem}blockquote p{margin:0}blockquote footer{font-size:80%;margin:1rem 0 0 0}dl dt{margin-bottom:0.5rem}dl dd{font-style:italic;margin-bottom:2rem}code,.highlight{overflow:auto}code{word-break:break-all}pre{padding:1em}.date{opacity:0.6}.highlight table td{padding:5px}.highlight table pre{margin:0}.highlight .gh{color:#999999}.highlight .sr{color:#f6aa11}.highlight .go{color:#888888}.highlight .gp{color:#555555}.highlight .gu{color:#aaaaaa}.highlight .nb{color:#f6aa11}.highlight .cm{color:#75715e}.highlight .cp{color:#75715e}.highlight .c1{color:#75715e}.highlight .cs{color:#75715e}.highlight .c,.highlight .ch,.highlight .cd,.highlight .cpf{color:#75715e}.highlight .err{color:#960050}.highlight .gr{color:#960050}.highlight .gt{color:#960050}.highlight .gd{color:#49483e}.highlight .gi{color:#49483e}.highlight .ge{color:#49483e}.highlight .kc{color:#66d9ef}.highlight .kd{color:#66d9ef}.highlight .kr{color:#66d9ef}.highlight .no{color:#66d9ef}.highlight .kt{color:#66d9ef}.highlight .mf{color:#ae81ff}.highlight .mh{color:#ae81ff}.highlight .il{color:#ae81ff}.highlight .mi{color:#ae81ff}.highlight .mo{color:#ae81ff}.highlight .m,.highlight .mb,.highlight .mx{color:#ae81ff}.highlight .sc{color:#ae81ff}.highlight .se{color:#ae81ff}.highlight .ss{color:#ae81ff}.highlight .sd{color:#e6db74}.highlight .s2{color:#e6db74}.highlight .sb{color:#e6db74}.highlight .sh{color:#e6db74}.highlight .si{color:#e6db74}.highlight .sx{color:#e6db74}.highlight .s1{color:#e6db74}.highlight .s,.highlight .sa,.highlight .dl{color:#e6db74}.highlight .na{color:#a6e22e}.highlight .nc{color:#a6e22e}.highlight .nd{color:#a6e22e}.highlight .ne{color:#a6e22e}.highlight .nf,.highlight .fm{color:#a6e22e}.highlight .vc{color:#ffffff;background-color:#272822}.highlight .nn{color:#ffffff;background-color:#272822}.highlight .nl{color:#ffffff;background-color:#272822}.highlight .ni{color:#ffffff;background-color:#272822}.highlight .bp{color:#ffffff;background-color:#272822}.highlight .vg{color:#ffffff;background-color:#272822}.highlight .vi{color:#ffffff;background-color:#272822}.highlight .nv,.highlight .vm{color:#ffffff;background-color:#272822}.highlight .w{color:#ffffff;background-color:#272822}.highlight{color:#ffffff;background-color:#272822}.highlight .n,.highlight .py,.highlight .nx{color:#ffffff;background-color:#272822}.highlight .ow{color:#f92672}.highlight .nt{color:#f92672}.highlight .k,.highlight .kv{color:#f92672}.highlight .kn{color:#f92672}.highlight .kp{color:#f92672}.highlight .o{color:#f92672}html{box-sizing:border-box;margin:0;padding:0}*,*:before,*:after{box-sizing:inherit}body{background-color:#edf2f7;color:#495057}header,main{margin:0 auto;max-width:50rem}main{background:white;border:2px solid #e9ecef;-webkit-box-shadow:0 0.75rem 1.5rem rgba(18,38,63,0.03);box-shadow:0 0.75rem 1.5rem rgba(18,38,63,0.03);padding:2rem 3rem}ul,ol{padding:0;list-style-position:inside}table{border-collapse:collapse;text-align:left;width:100%}table tr{border-bottom:1px solid black}table td{padding:0.5rem}img{width:100%;margin:0.5rem 0}nav ul{list-style:none !important;padding:0;text-align:right}nav ul li{display:inline-block}nav a,nav a:visited{margin:0.5rem;text-decoration:none;font-size:0.875rem;text-transform:uppercase;color:inherit}footer{margin:1rem 0;text-align:center;color:inherit}</style>
    <!-- Google Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-155884327-1', 'auto');
	ga('send', 'pageview', { 'page': location.pathname + location.search + location.hash});
	ga('set', 'anonymizeIp', false);
    </script>
    <!-- End Google Analytics -->
    </head><body> <span class="over"></span><header role="banner"><nav role="navigation"><ul><li><a href="/" >Home</a></li><li><a href="/categories" >Categories</a></li><li><a href="/tags" >Tags</a></li><li><a href="/search">Search</a></li><li><a href="/about" >About</a></li><li><a href="https://tinyletter.com/hoanhan">Insights</a></li></ul></nav></header><main id="main" role="main"><article role="article"><h1>Web Application Architecture 101</h1><time class="date" datetime="2020-03-22T00:00:00-04:00"> March 22, 2020 &middot; 2 mins read &middot; <a class="post" href="/category/System-design-notes">System design notes</a> </time><ul><li>Tiers<ul><li>A tier is a logical separation of components in an application or service - database, backend app, user interface, messaging, caching</li><li>Single tier: user interface, backend business logic, database reside in the same machine<ul><li>Pros: no network latency</li><li>Cons: hard to maintain once is shipped</li></ul></li><li>Two-tier: client (user interface, business logic) &amp; server (database)<ul><li>Communication happens over the HTTP protocol (request-response model &amp; stateless)</li><li>REST API takes advantage of the HTTP methodologies to establish communication between the client and the server</li></ul></li><li>Three-tier: user interface, application logic, database reside in different machines</li><li>N-tier: more than 3 components involved - cache, message queues, load balancers,…<ul><li>Single Responsibility Principle: a component has only a single responsibility</li><li>Separation of concerns: keep components separate, make them reusable</li></ul></li></ul></li><li>Scalability<ul><li>Ability to withstand increased workload without sacrificing the latency</li><li>Latency an be divided into 2 parts:<ul><li>Network latency: amount of time the network takes to send data packet from point A to B</li><li>Application latency: amount of time the application takes to process a user request</li></ul></li><li>Type of scalability<ul><li>Vertical scaling/scaling up: adding more power to server<ul><li>Pros: not a lot of overhead on monitoring, operating and maintaining</li><li>Cons: single point of failure</li></ul></li><li>Horizontal scaling/scaling out: adding more hardware to the existing resource pool<ul><li>Pros: cheaper, better fault-tolerance</li><li>Cons: managing server is hard, writing distributed computing program is also challenging</li></ul></li></ul></li><li>Common bottlenecks that hurt scalability<ul><li>Database latency</li><li>Poor application architecture</li><li>Not caching wisely</li><li>Inefficient configuration and load balancing</li><li>Adding business logic to the database</li><li>Badly written code</li></ul></li><li>Common strategies to improve and test the scalability<ul><li>Profiling</li><li>Cache wisely</li><li>Use a CDN</li><li>Compress data</li><li>Avoid unnecessary round trips between client and sever</li><li>Run load &amp; stress tests</li></ul></li></ul></li><li>High Availability<ul><li>Ability to stay online despite having failures at the infrastructural level in real-time</li><li>Common reasons for system failures<ul><li>Software crashes</li><li>Hardware crashes</li><li>Human error</li><li>Planned downtime</li></ul></li><li>A common way to add more availability is to have redundancy - duplicating the components &amp; keeping them on standby to take over in case the active instances go down</li></ul></li><li>Monolithic &amp; Microservices<ul><li>Monolithic: entire application code in a single codebase<ul><li>Pros: simple to develop, test, deploy as everything resides in one repo</li><li>Cons:<ul><li>Continuous deployment means re-deploying the entire application</li><li>Single point of failure</li><li>Hard to scale</li></ul></li></ul></li></ul></li></ul><p><br /> <strong>References:</strong></p><ul><li><a href="https://www.educative.io/courses/web-application-software-architecture-101">https://www.educative.io/courses/web-application-software-architecture-101</a></li></ul><br><div class="related"><h3><small>Related Posts:</small></h3><ul><li><a href="/2020/03/24/brief-history-scaling-linkedin">A Brief History of Scaling LinkedIn</a></li><li><a href="/2020/03/23/serverless-aws-lamda">Serverless architecture with AWS Lamda</a></li></ul></div><br><p> Tagged: <a class="post" href="/tag/architecture">#architecture</a></p><hr style="height:2px; border:none; margin: 2rem 0; background-color:#e7e9ee;"><div id="disqus_thread"></div><script> var disqus_name = "your username"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_name + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script> <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></article></main><footer class="footer" role="contentinfo"> <small> © 2020 <a style="text-decoration: none;" href="/about">Hoanh An</a> | <a style="text-decoration: none;" href="https://www.linkedin.com/in/hoanhan101/">LinkedIn</a> | <a style="text-decoration: none;" href="https://github.com/hoanhan101">GitHub</a> | <a style="text-decoration: none;" href="mailto:hoanhan101@gmail.com">Email</a> </small></footer></body></html>
