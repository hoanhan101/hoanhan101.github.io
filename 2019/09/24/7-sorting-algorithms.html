<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>7 sorting algorithms | Gray - Single column blog and portfolio Jekyll theme</title><meta name="generator" content="Jekyll v3.7.4" /><meta property="og:title" content="7 sorting algorithms" /><meta property="og:locale" content="en_US" /><meta name="description" content="Here are 7 sorting algorithms implementations in Go that we are going to cover in this post: Bubble Sort Selection Sort Insertion Sort Merge Sort Quicksort Heapsort Counting Sort" /><meta property="og:description" content="Here are 7 sorting algorithms implementations in Go that we are going to cover in this post: Bubble Sort Selection Sort Insertion Sort Merge Sort Quicksort Heapsort Counting Sort" /><meta property="og:site_name" content="Gray - Single column blog and portfolio Jekyll theme" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-09-24T00:00:00-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="7 sorting algorithms" /><meta name="twitter:site" content="@" /> <script type="application/ld+json"> {"url":"/2019/09/24/7-sorting-algorithms","headline":"7 sorting algorithms","dateModified":"2019-09-24T00:00:00-04:00","datePublished":"2019-09-24T00:00:00-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/09/24/7-sorting-algorithms"},"description":"Here are 7 sorting algorithms implementations in Go that we are going to cover in this post: Bubble Sort Selection Sort Insertion Sort Merge Sort Quicksort Heapsort Counting Sort","@type":"BlogPosting","@context":"https://schema.org"}</script><link rel="shortcut icon" href="/favicon.png"><link rel="alternate" type="application/atom+xml" title="Gray - Single column blog and portfolio Jekyll theme" href="/atom.xml"><link rel="alternate" title="Gray - Single column blog and portfolio Jekyll theme" type="application/json" href="/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style type="text/css"> body{font-family:-apple-system,BlinkMacSystemFont,'avenir next',avenir,Noto Sans,helvetica,'helvetica neue',sans-serif}body{font-size:1rem;line-height:1.5;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility}a,a:visited{color:inherit}a:hover,a:visited:hover{color:dodgerblue}blockquote{background:#f9f9f9;border-left:5px solid black;font-size:120%;margin:2rem 0;padding:1rem}blockquote p{margin:0}blockquote footer{font-size:80%;margin:1rem 0 0 0}dl dt{margin-bottom:0.5rem}dl dd{font-style:italic;margin-bottom:2rem}code,.highlight{overflow:auto}code{word-break:break-all}code{padding:0.1rem 0.3rem}pre{padding:1em}.date{opacity:0.6}.highlight table td{padding:5px}.highlight table pre{margin:0}.highlight .gh{color:#999999}.highlight .sr{color:#f6aa11}.highlight .go{color:#888888}.highlight .gp{color:#555555}.highlight .gu{color:#aaaaaa}.highlight .nb{color:#f6aa11}.highlight .cm{color:#75715e}.highlight .cp{color:#75715e}.highlight .c1{color:#75715e}.highlight .cs{color:#75715e}.highlight .c,.highlight .ch,.highlight .cd,.highlight .cpf{color:#75715e}.highlight .err{color:#960050}.highlight .gr{color:#960050}.highlight .gt{color:#960050}.highlight .gd{color:#49483e}.highlight .gi{color:#49483e}.highlight .ge{color:#49483e}.highlight .kc{color:#66d9ef}.highlight .kd{color:#66d9ef}.highlight .kr{color:#66d9ef}.highlight .no{color:#66d9ef}.highlight .kt{color:#66d9ef}.highlight .mf{color:#ae81ff}.highlight .mh{color:#ae81ff}.highlight .il{color:#ae81ff}.highlight .mi{color:#ae81ff}.highlight .mo{color:#ae81ff}.highlight .m,.highlight .mb,.highlight .mx{color:#ae81ff}.highlight .sc{color:#ae81ff}.highlight .se{color:#ae81ff}.highlight .ss{color:#ae81ff}.highlight .sd{color:#e6db74}.highlight .s2{color:#e6db74}.highlight .sb{color:#e6db74}.highlight .sh{color:#e6db74}.highlight .si{color:#e6db74}.highlight .sx{color:#e6db74}.highlight .s1{color:#e6db74}.highlight .s,.highlight .sa,.highlight .dl{color:#e6db74}.highlight .na{color:#a6e22e}.highlight .nc{color:#a6e22e}.highlight .nd{color:#a6e22e}.highlight .ne{color:#a6e22e}.highlight .nf,.highlight .fm{color:#a6e22e}.highlight .vc{color:#ffffff;background-color:#272822}.highlight .nn{color:#ffffff;background-color:#272822}.highlight .nl{color:#ffffff;background-color:#272822}.highlight .ni{color:#ffffff;background-color:#272822}.highlight .bp{color:#ffffff;background-color:#272822}.highlight .vg{color:#ffffff;background-color:#272822}.highlight .vi{color:#ffffff;background-color:#272822}.highlight .nv,.highlight .vm{color:#ffffff;background-color:#272822}.highlight .w{color:#ffffff;background-color:#272822}.highlight{color:#ffffff;background-color:#272822}.highlight .n,.highlight .py,.highlight .nx{color:#ffffff;background-color:#272822}.highlight .ow{color:#f92672}.highlight .nt{color:#f92672}.highlight .k,.highlight .kv{color:#f92672}.highlight .kn{color:#f92672}.highlight .kp{color:#f92672}.highlight .o{color:#f92672}html{box-sizing:border-box;margin:0;padding:0}*,*:before,*:after{box-sizing:inherit}body{background-color:#edf2f7;color:#495057}header,main{margin:0 auto;max-width:50rem}main{background:white;border:2px solid #e9ecef;-webkit-box-shadow:0 0.75rem 1.5rem rgba(18,38,63,0.03);box-shadow:0 0.75rem 1.5rem rgba(18,38,63,0.03);padding:2rem 3rem}ul,ol{padding:0;list-style-position:inside}table{border-collapse:collapse;text-align:left;width:100%}table tr{border-bottom:1px solid black}table td{padding:0.5rem}img{width:100%;margin:0.5rem 0}nav ul{list-style:none !important;padding:0;text-align:right}nav ul li{display:inline-block}nav a,nav a:visited{margin:0.5rem;text-decoration:none;font-size:0.875rem;text-transform:uppercase;color:inherit}footer{margin:1rem 0;text-align:center;color:inherit}</style></head><body> <span class="over"></span><header role="banner"><nav role="navigation"><ul><li><a href="/" >Home</a></li><li><a href="/tags" >Tags</a></li><li><a href="/about" >About</a></li><li><a href="https://tinyletter.com/hoanhan">ðŸ“¥</a></li></ul></nav></header><main id="main" role="main"><article role="article"><h1>7 sorting algorithms</h1><time class="date" datetime="2019-09-24T00:00:00-04:00">September 24, 2019</time><p>Here are 7 sorting algorithms implementations in Go that we are going to cover in this post:</p><ol><li>Bubble Sort</li><li>Selection Sort</li><li>Insertion Sort</li><li>Merge Sort</li><li>Quicksort</li><li>Heapsort</li><li>Counting Sort</li></ol><h2 id="bubble-sort">Bubble Sort</h2><p>Approach:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Repeatedly swap the adjacent elements if they are in the wrong order in the
array, one item at a time.
</code></pre></div></div><p>Cost:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>O(n^2) time and O(1) space.
</code></pre></div></div><p>Solution:</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">bubbleSort</span><span class="p">(</span><span class="n">in</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>

	<span class="c">// for each element in the list, check it with almost every other element.</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c">// since the last i element is already in place, only iterate through</span>
		<span class="c">// the item before the last one.</span>
		<span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="m">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="c">// swap the adjacent elements if they are not in ascending order.</span>
			<span class="k">if</span> <span class="n">in</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">in</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="m">1</span><span class="p">]</span> <span class="p">{</span>
				<span class="n">common</span><span class="o">.</span><span class="n">Swap</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="m">1</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="selection-sort">Selection Sort</h2><p>Approach:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Repeatedly select the next smallest element from the unsorted array and move it
to the front.
</code></pre></div></div><p>Cost:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>O(n^2) time and O(1) space.
</code></pre></div></div><p>Solution:</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">selectionSort</span><span class="p">(</span><span class="n">in</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">minIndex</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">minIndex</span> <span class="o">=</span> <span class="n">i</span>
		<span class="c">// find the minimum in the rest of the array.</span>
		<span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="m">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">in</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">in</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">in</span><span class="p">[</span><span class="n">minIndex</span><span class="p">]</span> <span class="p">{</span>
				<span class="n">minIndex</span> <span class="o">=</span> <span class="n">j</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c">// swap the minimum value with the first value.</span>
		<span class="n">common</span><span class="o">.</span><span class="n">Swap</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">minIndex</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="insertion-sort">Insertion Sort</h2><p>Approach:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Insert elements from an unsorted array into a sorted subsection of the
array, one item at a time.
</code></pre></div></div><p>Cost:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>O(n^2) time and O(1) space.
</code></pre></div></div><p>Solution:</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">insertionSort</span><span class="p">(</span><span class="n">in</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// iterate through the list from position 1.</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">in</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c">// shift each one to the left by swapping it with the one before until</span>
		<span class="c">// it's in the right spot.</span>
		<span class="n">current</span> <span class="o">:=</span> <span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="n">j</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">-</span> <span class="m">1</span>

		<span class="k">for</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">current</span> <span class="o">&lt;</span> <span class="n">in</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">{</span>
			<span class="n">in</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="m">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
			<span class="n">j</span><span class="o">--</span>
		<span class="p">}</span>

		<span class="n">in</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="m">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="merge-sort">Merge Sort</h2><p>Approach:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Split the input in half, recursively sorts each half, then merge the
sorted halves back together.
</code></pre></div></div><p>Cost:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>O(nlogn) time and O(n) space.
</code></pre></div></div><p>Solution:</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">mergeSort</span><span class="p">(</span><span class="n">in</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="c">// base case</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="m">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">in</span>
	<span class="p">}</span>

	<span class="c">// split the input in half.</span>
	<span class="n">middleIndex</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="o">/</span> <span class="m">2</span>
	<span class="n">left</span> <span class="o">:=</span> <span class="n">in</span><span class="p">[</span><span class="o">:</span><span class="n">middleIndex</span><span class="p">]</span>
	<span class="n">right</span> <span class="o">:=</span> <span class="n">in</span><span class="p">[</span><span class="n">middleIndex</span><span class="o">:</span><span class="p">]</span>

	<span class="c">// sort each half.</span>
	<span class="n">leftSorted</span> <span class="o">:=</span> <span class="n">mergeSort</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
	<span class="n">rightSorted</span> <span class="o">:=</span> <span class="n">mergeSort</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

	<span class="c">// merge the sorted halves.</span>
	<span class="k">return</span> <span class="n">mergeSortedArray</span><span class="p">(</span><span class="n">leftSorted</span><span class="p">,</span> <span class="n">rightSorted</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">mergeSortedArray</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="n">out</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>

	<span class="c">// keep two "pointer" at index 0 and move up accordingly as one get</span>
	<span class="c">// merged in.</span>
	<span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">a1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">{</span>
			<span class="n">out</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">a1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">i</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">out</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">a2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
			<span class="n">j</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c">// if we get here, one array must have bigger size than the other. could</span>
	<span class="c">// figure out which one is it then copy the rest of its to our final one.</span>
	<span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">out</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">a1</span><span class="p">[</span><span class="n">i</span><span class="o">:</span><span class="p">]</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">out</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">a2</span><span class="p">[</span><span class="n">j</span><span class="o">:</span><span class="p">]</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">out</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="quicksort">Quicksort</h2><p>Approach:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Recursively divide the input into two smaller arrays around a pivot, where
one half has items smaller than the pivot, other half has items bigger than
the pivot.
</code></pre></div></div><p>Cost:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>O(nlogn) time and O(nlogn) space.
</code></pre></div></div><p>Solution:</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">quicksort</span><span class="p">(</span><span class="n">in</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="p">{</span>
		<span class="c">// pi is the pivot/partition index.</span>
		<span class="n">pi</span> <span class="o">:=</span> <span class="n">partition</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

		<span class="c">// sort the items before and after partition.</span>
		<span class="n">quicksort</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">pi</span><span class="o">-</span><span class="m">1</span><span class="p">)</span>
		<span class="n">quicksort</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">pi</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">partition</span><span class="p">(</span><span class="n">in</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">pivot</span> <span class="o">:=</span> <span class="n">in</span><span class="p">[</span><span class="n">end</span><span class="p">]</span>

	<span class="n">left</span> <span class="o">:=</span> <span class="n">start</span>
	<span class="n">right</span> <span class="o">:=</span> <span class="n">end</span> <span class="o">-</span> <span class="m">1</span>

	<span class="k">for</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="p">{</span>
		<span class="c">// keep going until we find something on the left that belongs to the</span>
		<span class="c">// right.</span>
		<span class="k">for</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">in</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pivot</span> <span class="p">{</span>
			<span class="n">left</span><span class="o">++</span>
		<span class="p">}</span>

		<span class="c">// keep going until we find something on the right that belongs to the</span>
		<span class="c">// left.</span>
		<span class="k">for</span> <span class="n">right</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">in</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">pivot</span> <span class="p">{</span>
			<span class="n">right</span><span class="o">--</span>
		<span class="p">}</span>

		<span class="c">// by swapping the item at left and right index, we move the item that</span>
		<span class="c">// is smaller than the pivot to the left half and vice versa.</span>
		<span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="p">{</span>
			<span class="n">common</span><span class="o">.</span><span class="n">Swap</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c">// once the partition is finished, move the pivot back to its final</span>
			<span class="c">// position by swapping the item at left and end index.</span>
			<span class="n">common</span><span class="o">.</span><span class="n">Swap</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">left</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="heapsort">Heapsort</h2><p>Approach:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Similar to selection sort, repeatedly choose the largest item and move it to
the end of the array using a max heap.
</code></pre></div></div><p>Cost:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>O(nlogn) time and O(1) space.
</code></pre></div></div><p>Solution:</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">heapsort</span><span class="p">(</span><span class="n">in</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">heapify</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>

	<span class="n">size</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="c">// repeatedly remove the largest item.</span>
		<span class="n">largest</span> <span class="o">:=</span> <span class="n">removeLargest</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

		<span class="c">// update the heap size.</span>
		<span class="n">size</span><span class="o">--</span>

		<span class="c">// store the removed value at the end of the list.</span>
		<span class="n">in</span><span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="n">largest</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// heapify transform the input into a max heap.</span>
<span class="k">func</span> <span class="n">heapify</span><span class="p">(</span><span class="n">in</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="o">-</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="o">-</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="n">bubbleDown</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// bubbleDown allow larger values to reach the top.</span>
<span class="k">func</span> <span class="n">bubbleDown</span><span class="p">(</span><span class="n">heap</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">heapSize</span> <span class="kt">int</span><span class="p">,</span> <span class="n">index</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">heapSize</span> <span class="p">{</span>
		<span class="c">// fast-calculate the children left and right index.</span>
		<span class="n">left</span> <span class="o">:=</span> <span class="n">index</span><span class="o">*</span><span class="m">2</span> <span class="o">+</span> <span class="m">1</span>
		<span class="n">right</span> <span class="o">:=</span> <span class="n">index</span><span class="o">*</span><span class="m">2</span> <span class="o">+</span> <span class="m">2</span>

		<span class="c">// stop if there is no child node.</span>
		<span class="k">if</span> <span class="n">left</span> <span class="o">&gt;=</span> <span class="n">heapSize</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>

		<span class="c">// find the larger index</span>
		<span class="n">larger</span> <span class="o">:=</span> <span class="n">left</span>
		<span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">heapSize</span> <span class="o">&amp;&amp;</span> <span class="n">heap</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="p">{</span>
			<span class="n">larger</span> <span class="o">=</span> <span class="n">right</span>
		<span class="p">}</span>

		<span class="c">// if the current item is larger than both children, we're done.</span>
		<span class="c">// if not, swap with the larger child.</span>
		<span class="k">if</span> <span class="n">heap</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">larger</span><span class="p">]</span> <span class="p">{</span>
			<span class="n">common</span><span class="o">.</span><span class="n">Swap</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">larger</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// removeLargest remove and return the largest item from the heap.</span>
<span class="k">func</span> <span class="n">removeLargest</span><span class="p">(</span><span class="n">heap</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">heapSize</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c">// largest item is at the top of our max heap.</span>
	<span class="n">largest</span> <span class="o">:=</span> <span class="n">heap</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>

	<span class="c">// move the last item into the root position.</span>
	<span class="n">heap</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="n">heapSize</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>

	<span class="c">// bubble down from the root to restore the heap.</span>
	<span class="n">bubbleDown</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">heapSize</span><span class="o">-</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">largest</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="counting-sort">Counting Sort</h2><p>Approach:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Iterate through the input, count the number of times each item occurs, use
these counts to compute each item's index in the final sorted array.
</code></pre></div></div><p>Cost:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>O(n) time and O(n) space.
</code></pre></div></div><p>Solution:</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">countingSort</span><span class="p">(</span><span class="n">in</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">max</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="c">// utilize max value to create a fix-sized list of item counts.</span>
	<span class="n">counts</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="n">max</span><span class="o">+</span><span class="m">1</span><span class="p">)</span>
	<span class="n">out</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>

	<span class="c">// populate the array where its indices represent items themselves and</span>
	<span class="c">// its values represent how many time the item appears.</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">in</span> <span class="p">{</span>
		<span class="n">counts</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="o">++</span>
	<span class="p">}</span>

	<span class="c">// iterate through the counts and add the item to the output list.</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">counts</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">:=</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

		<span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">out</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">out</span>
<span class="p">}</span>
</code></pre></div></div><blockquote><p>For more coding problems, please visit <a href="https://github.com/hoanhan101/algo">https://github.com/hoanhan101/algo</a>.</p></blockquote><blockquote><p>If youâ€™re interested in getting updates for these content like this, consider joining my <a href="https://tinyletter.com/hoanhan">mail list here â†’</a></p></blockquote><br><p> Tagged <a class="post" href="/tag/algorithm">#algorithm</a>, <a class="post" href="/tag/sorting">#sorting</a>.</p><hr style="height:2px; border:none; margin: 2rem 0; background-color:#e7e9ee;"><div id="disqus_thread"></div><script> var disqus_name = "your username"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_name + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script> <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></article></main><footer class="footer" role="contentinfo"> <small> Â© Hoanh An </small></footer></body></html>
