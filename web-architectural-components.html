<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Modern Web Architectural Components | Hoanh An</title><meta name="generator" content="Jekyll v3.7.4" /><meta property="og:title" content="Modern Web Architectural Components" /><meta name="author" content="Hoanh An" /><meta property="og:locale" content="en_US" /><meta name="description" content="Tiers A tier is a logical separation of components in an application or service - database, backend app, user interface, messaging, caching Single tier: user interface, backend business logic, database reside in the same machine Pros: no network latency Cons: hard to maintain once is shipped Two-tier: client (user interface, business logic) &amp; server (database) Communication happens over the HTTP protocol (request-response model &amp; stateless) REST API takes advantage of the HTTP methodologies to establish communication between the client and the server Three-tier: user interface, application logic, database reside in different machines N-tier: more than 3 components involved - cache, message queues, load balancers,… Single Responsibility Principle: a component has only a single responsibility Separation of concerns: keep components separate, make them reusable Scalability Ability to withstand increased workload without sacrificing the latency Latency can be divided into 2 parts: Network latency: amount of time the network takes to send data packet from point A to B Application latency: amount of time the application takes to process a user request Type of scalability Vertical scaling/scaling up: adding more power to server Pros: not a lot of overhead on monitoring, operating and maintaining Cons: single point of failure Horizontal scaling/scaling out: adding more hardware to the existing resource pool Pros: cheaper, better fault-tolerance Cons: managing server is hard, writing distributed computing program is also challenging Common bottlenecks that hurt scalability Database latency Poor application architecture Not caching wisely Inefficient configuration and load balancing Adding business logic to the database Badly written code Common strategies to improve and test the scalability Profiling Cache wisely Use a CDN Compress data Avoid unnecessary round trips between client and sever Run load &amp; stress tests High Availability Ability to stay online despite having failures at the infrastructural level in real-time Common reasons for system failures Software crashes Hardware crashes Human error Planned downtime A common way to add more availability is to have redundancy - duplicating the components &amp; keeping them on standby to take over in case the active instances go down Monolithic &amp; Microservices Monolithic: entire application code in a single service Pros: simple to develop, test, deploy as everything resides in one repo Cons: Continuous deployment means re-deploying the entire application Single point of failure Hard to scale Microservices: tasks are split into separate services forming a larger service as a whole Pros: No single point of failure Easier to scale independently Cons: Difficult to manage No strong consistency Database Forms of data: Structured: conforms to a certain structure, stored in a normalized fashion Unstructured: no definite structure, could be text, image, video, multimedia files, machine-generated data Semi-structured: mix of structured and unstructured data, stored in XML or JSON User state: user logs and activity on the platform Why the need for NoSQL while relational database is still doing fine? Scaling relational database is not trivial, which requires Sharding or Replicating NoSQL is fast with read-write and really easy to scale out Eventual consistency over strong consistency Eventual consistency: achieve high availability that informally guarantees that, if no new updates are made, return the last updated value for all accesses Strong consistency: data has to be strongly consistent at all times Data analytics Polyglot persistence Use different storage technologies to handle different needs within a given software application Multi-model databases reduce the operational complexity of using several different database models in an application by supporting multiple data models via a single API CAP theorem It is impossible for a distributed data store to simultaneously provide more than two out of the following three guarantees: Consistency: every read receives the most recent write Availability: every request receives a non-error response Partition tolerance: system continues to operate despite network failures Types of databases Document-oriented: generally semi-structured &amp; stored in a JSON-like format Use cases: Working with semi-structured data Need a flexible schema Examples are real-time feeds, live sport apps, web-based multiplayer games Real life implementations SEGA uses Mongo-DB to simply ops and improve gaming experiences Coinbase uses MongoDB to scale from 15k to 1.2 million requests per minute Graph: store data in nodes/vertices and edges in the form of relationships Use cases: Maps Social graphs Recommendation engines Storing genetic data Real life implementations Walmart uses Neo4J to show product recommendations in real-time NASA uses Neo4J to store “lessons learned” data Key-value: use a simple key-value method to store and quickly fetch the data Use cases: Caching Implementing queue Managing real-time data Real life implementations Inovonics uses Redis to drive real-time analytics on millions of sensor data Microsoft uses Redis to handle the traffic spike on its platforms Google Cloud uses Memcache to implement caching on their cloud platform Time series: optimized for tracking &amp; persisting time series data Use cases: Managing data in real-time &amp; continually over a long period of time Managing data for running analytics &amp; monitoring Real life implementations IBM uses Influx DB to run analytics for real-time cognitive fraud detection Spiio uses Influx DB to remotely monitor vertical lining green walls &amp; plant installations Wide Column: primarily used to handle massive amounts of data Use cases: Managing big data Real life implementations Netflix uses Cassandra as the backend database for the streaming service Adobe uses HBase for processing large amounts of data Caching Ensure low latency and high throughput Strategies Cache Aside: First look in the cache, return if present, else fetch from the database and update cache Has a TTL (Time To Live) period to sync up data Works well for read-heavy workloads like user profile data Read-through Similar to Cache Aside, but the cache is always up-to-date Write-through Cache before writing to database Works well for write-heavy workloads like MMOs Write-back Similar to Write-through, but add some delay before writing to database Message queue Features: Facilitate asynchronous behaviour (background processes, tasks, batch jobs) Facilitate cross-module communication Provide temporary storage for storing messages until they’re consumed Models: Publish-subscribe (Pub-sub): one to many relationship Point to point: one to one relationship Protocols: Advanced Message Queuing Protocol (AMQP) Streaming Text Oriented Messaging Protocol (STOMP) Real life implementations LinkedIn Real-Time Architecture Facebook’s Live Streaming architecture Stream processing Layers of data processing setup: Data collection/query layer Data standardization layer Data processing layer Data analysis layer Data visualization layer Data storage layer Data security layer Ways to ingest data: Real-time Batching Challenges: Formatting, standardizing, converting data from multiple resources is a slow and tedious process It’s resource-intensive Moving data around is risky Use cases: Moving data into Hadoop Streaming data to Elastic search Log processing Real-time streaming Distributed data processing Diverge large amounts of data to several different nodes for parallel processing Popular frameworks: MapReduce - Apache Hadoop Apache Spark Apache Storm Apache Kafka Architecture Lambda leverages both real-time and batching process that consists 3 layers Batch: deals with results from the batching process Speed: gets data from the real-time streaming process Serving: combines the results from the Batch and Speed layers Kappa has only a single pipeline and only contains Speed and Serving layers Preferred if the batch and the streaming analytics results are fairly identical Real life implementations Netflix’ Keystone Real-time Stream Processing Platform Netflix’ Migrating Batch ETL to Stream Processing Other architectures Event-driven: capable of handling a big number of concurrent requests with minimal resources WebHooks: have an event-based mechanism that only fires an HTTP event to consumers whenever new info is available Share Nothing: every module has its own environment Hexagonal: Port: act as an API, interface Adapter: an implementation of the interface, convert data from Port to be consumed by Domain Domain: contain business logic Peer to Peer: nodes can communicate with each other without the need of a central server Decentralized social network" /><meta property="og:description" content="Tiers A tier is a logical separation of components in an application or service - database, backend app, user interface, messaging, caching Single tier: user interface, backend business logic, database reside in the same machine Pros: no network latency Cons: hard to maintain once is shipped Two-tier: client (user interface, business logic) &amp; server (database) Communication happens over the HTTP protocol (request-response model &amp; stateless) REST API takes advantage of the HTTP methodologies to establish communication between the client and the server Three-tier: user interface, application logic, database reside in different machines N-tier: more than 3 components involved - cache, message queues, load balancers,… Single Responsibility Principle: a component has only a single responsibility Separation of concerns: keep components separate, make them reusable Scalability Ability to withstand increased workload without sacrificing the latency Latency can be divided into 2 parts: Network latency: amount of time the network takes to send data packet from point A to B Application latency: amount of time the application takes to process a user request Type of scalability Vertical scaling/scaling up: adding more power to server Pros: not a lot of overhead on monitoring, operating and maintaining Cons: single point of failure Horizontal scaling/scaling out: adding more hardware to the existing resource pool Pros: cheaper, better fault-tolerance Cons: managing server is hard, writing distributed computing program is also challenging Common bottlenecks that hurt scalability Database latency Poor application architecture Not caching wisely Inefficient configuration and load balancing Adding business logic to the database Badly written code Common strategies to improve and test the scalability Profiling Cache wisely Use a CDN Compress data Avoid unnecessary round trips between client and sever Run load &amp; stress tests High Availability Ability to stay online despite having failures at the infrastructural level in real-time Common reasons for system failures Software crashes Hardware crashes Human error Planned downtime A common way to add more availability is to have redundancy - duplicating the components &amp; keeping them on standby to take over in case the active instances go down Monolithic &amp; Microservices Monolithic: entire application code in a single service Pros: simple to develop, test, deploy as everything resides in one repo Cons: Continuous deployment means re-deploying the entire application Single point of failure Hard to scale Microservices: tasks are split into separate services forming a larger service as a whole Pros: No single point of failure Easier to scale independently Cons: Difficult to manage No strong consistency Database Forms of data: Structured: conforms to a certain structure, stored in a normalized fashion Unstructured: no definite structure, could be text, image, video, multimedia files, machine-generated data Semi-structured: mix of structured and unstructured data, stored in XML or JSON User state: user logs and activity on the platform Why the need for NoSQL while relational database is still doing fine? Scaling relational database is not trivial, which requires Sharding or Replicating NoSQL is fast with read-write and really easy to scale out Eventual consistency over strong consistency Eventual consistency: achieve high availability that informally guarantees that, if no new updates are made, return the last updated value for all accesses Strong consistency: data has to be strongly consistent at all times Data analytics Polyglot persistence Use different storage technologies to handle different needs within a given software application Multi-model databases reduce the operational complexity of using several different database models in an application by supporting multiple data models via a single API CAP theorem It is impossible for a distributed data store to simultaneously provide more than two out of the following three guarantees: Consistency: every read receives the most recent write Availability: every request receives a non-error response Partition tolerance: system continues to operate despite network failures Types of databases Document-oriented: generally semi-structured &amp; stored in a JSON-like format Use cases: Working with semi-structured data Need a flexible schema Examples are real-time feeds, live sport apps, web-based multiplayer games Real life implementations SEGA uses Mongo-DB to simply ops and improve gaming experiences Coinbase uses MongoDB to scale from 15k to 1.2 million requests per minute Graph: store data in nodes/vertices and edges in the form of relationships Use cases: Maps Social graphs Recommendation engines Storing genetic data Real life implementations Walmart uses Neo4J to show product recommendations in real-time NASA uses Neo4J to store “lessons learned” data Key-value: use a simple key-value method to store and quickly fetch the data Use cases: Caching Implementing queue Managing real-time data Real life implementations Inovonics uses Redis to drive real-time analytics on millions of sensor data Microsoft uses Redis to handle the traffic spike on its platforms Google Cloud uses Memcache to implement caching on their cloud platform Time series: optimized for tracking &amp; persisting time series data Use cases: Managing data in real-time &amp; continually over a long period of time Managing data for running analytics &amp; monitoring Real life implementations IBM uses Influx DB to run analytics for real-time cognitive fraud detection Spiio uses Influx DB to remotely monitor vertical lining green walls &amp; plant installations Wide Column: primarily used to handle massive amounts of data Use cases: Managing big data Real life implementations Netflix uses Cassandra as the backend database for the streaming service Adobe uses HBase for processing large amounts of data Caching Ensure low latency and high throughput Strategies Cache Aside: First look in the cache, return if present, else fetch from the database and update cache Has a TTL (Time To Live) period to sync up data Works well for read-heavy workloads like user profile data Read-through Similar to Cache Aside, but the cache is always up-to-date Write-through Cache before writing to database Works well for write-heavy workloads like MMOs Write-back Similar to Write-through, but add some delay before writing to database Message queue Features: Facilitate asynchronous behaviour (background processes, tasks, batch jobs) Facilitate cross-module communication Provide temporary storage for storing messages until they’re consumed Models: Publish-subscribe (Pub-sub): one to many relationship Point to point: one to one relationship Protocols: Advanced Message Queuing Protocol (AMQP) Streaming Text Oriented Messaging Protocol (STOMP) Real life implementations LinkedIn Real-Time Architecture Facebook’s Live Streaming architecture Stream processing Layers of data processing setup: Data collection/query layer Data standardization layer Data processing layer Data analysis layer Data visualization layer Data storage layer Data security layer Ways to ingest data: Real-time Batching Challenges: Formatting, standardizing, converting data from multiple resources is a slow and tedious process It’s resource-intensive Moving data around is risky Use cases: Moving data into Hadoop Streaming data to Elastic search Log processing Real-time streaming Distributed data processing Diverge large amounts of data to several different nodes for parallel processing Popular frameworks: MapReduce - Apache Hadoop Apache Spark Apache Storm Apache Kafka Architecture Lambda leverages both real-time and batching process that consists 3 layers Batch: deals with results from the batching process Speed: gets data from the real-time streaming process Serving: combines the results from the Batch and Speed layers Kappa has only a single pipeline and only contains Speed and Serving layers Preferred if the batch and the streaming analytics results are fairly identical Real life implementations Netflix’ Keystone Real-time Stream Processing Platform Netflix’ Migrating Batch ETL to Stream Processing Other architectures Event-driven: capable of handling a big number of concurrent requests with minimal resources WebHooks: have an event-based mechanism that only fires an HTTP event to consumers whenever new info is available Share Nothing: every module has its own environment Hexagonal: Port: act as an API, interface Adapter: an implementation of the interface, convert data from Port to be consumed by Domain Domain: contain business logic Peer to Peer: nodes can communicate with each other without the need of a central server Decentralized social network" /><link rel="canonical" href="https://hoanhan101.github.io/web-architectural-components" /><meta property="og:url" content="https://hoanhan101.github.io/web-architectural-components" /><meta property="og:site_name" content="Hoanh An" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-03-28T00:00:00-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Modern Web Architectural Components" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Hoanh An" /> <script type="application/ld+json"> {"url":"https://hoanhan101.github.io/web-architectural-components","mainEntityOfPage":{"@type":"WebPage","@id":"https://hoanhan101.github.io/web-architectural-components"},"author":{"@type":"Person","name":"Hoanh An"},"headline":"Modern Web Architectural Components","dateModified":"2020-03-28T00:00:00-04:00","datePublished":"2020-03-28T00:00:00-04:00","description":"Tiers A tier is a logical separation of components in an application or service - database, backend app, user interface, messaging, caching Single tier: user interface, backend business logic, database reside in the same machine Pros: no network latency Cons: hard to maintain once is shipped Two-tier: client (user interface, business logic) &amp; server (database) Communication happens over the HTTP protocol (request-response model &amp; stateless) REST API takes advantage of the HTTP methodologies to establish communication between the client and the server Three-tier: user interface, application logic, database reside in different machines N-tier: more than 3 components involved - cache, message queues, load balancers,… Single Responsibility Principle: a component has only a single responsibility Separation of concerns: keep components separate, make them reusable Scalability Ability to withstand increased workload without sacrificing the latency Latency can be divided into 2 parts: Network latency: amount of time the network takes to send data packet from point A to B Application latency: amount of time the application takes to process a user request Type of scalability Vertical scaling/scaling up: adding more power to server Pros: not a lot of overhead on monitoring, operating and maintaining Cons: single point of failure Horizontal scaling/scaling out: adding more hardware to the existing resource pool Pros: cheaper, better fault-tolerance Cons: managing server is hard, writing distributed computing program is also challenging Common bottlenecks that hurt scalability Database latency Poor application architecture Not caching wisely Inefficient configuration and load balancing Adding business logic to the database Badly written code Common strategies to improve and test the scalability Profiling Cache wisely Use a CDN Compress data Avoid unnecessary round trips between client and sever Run load &amp; stress tests High Availability Ability to stay online despite having failures at the infrastructural level in real-time Common reasons for system failures Software crashes Hardware crashes Human error Planned downtime A common way to add more availability is to have redundancy - duplicating the components &amp; keeping them on standby to take over in case the active instances go down Monolithic &amp; Microservices Monolithic: entire application code in a single service Pros: simple to develop, test, deploy as everything resides in one repo Cons: Continuous deployment means re-deploying the entire application Single point of failure Hard to scale Microservices: tasks are split into separate services forming a larger service as a whole Pros: No single point of failure Easier to scale independently Cons: Difficult to manage No strong consistency Database Forms of data: Structured: conforms to a certain structure, stored in a normalized fashion Unstructured: no definite structure, could be text, image, video, multimedia files, machine-generated data Semi-structured: mix of structured and unstructured data, stored in XML or JSON User state: user logs and activity on the platform Why the need for NoSQL while relational database is still doing fine? Scaling relational database is not trivial, which requires Sharding or Replicating NoSQL is fast with read-write and really easy to scale out Eventual consistency over strong consistency Eventual consistency: achieve high availability that informally guarantees that, if no new updates are made, return the last updated value for all accesses Strong consistency: data has to be strongly consistent at all times Data analytics Polyglot persistence Use different storage technologies to handle different needs within a given software application Multi-model databases reduce the operational complexity of using several different database models in an application by supporting multiple data models via a single API CAP theorem It is impossible for a distributed data store to simultaneously provide more than two out of the following three guarantees: Consistency: every read receives the most recent write Availability: every request receives a non-error response Partition tolerance: system continues to operate despite network failures Types of databases Document-oriented: generally semi-structured &amp; stored in a JSON-like format Use cases: Working with semi-structured data Need a flexible schema Examples are real-time feeds, live sport apps, web-based multiplayer games Real life implementations SEGA uses Mongo-DB to simply ops and improve gaming experiences Coinbase uses MongoDB to scale from 15k to 1.2 million requests per minute Graph: store data in nodes/vertices and edges in the form of relationships Use cases: Maps Social graphs Recommendation engines Storing genetic data Real life implementations Walmart uses Neo4J to show product recommendations in real-time NASA uses Neo4J to store “lessons learned” data Key-value: use a simple key-value method to store and quickly fetch the data Use cases: Caching Implementing queue Managing real-time data Real life implementations Inovonics uses Redis to drive real-time analytics on millions of sensor data Microsoft uses Redis to handle the traffic spike on its platforms Google Cloud uses Memcache to implement caching on their cloud platform Time series: optimized for tracking &amp; persisting time series data Use cases: Managing data in real-time &amp; continually over a long period of time Managing data for running analytics &amp; monitoring Real life implementations IBM uses Influx DB to run analytics for real-time cognitive fraud detection Spiio uses Influx DB to remotely monitor vertical lining green walls &amp; plant installations Wide Column: primarily used to handle massive amounts of data Use cases: Managing big data Real life implementations Netflix uses Cassandra as the backend database for the streaming service Adobe uses HBase for processing large amounts of data Caching Ensure low latency and high throughput Strategies Cache Aside: First look in the cache, return if present, else fetch from the database and update cache Has a TTL (Time To Live) period to sync up data Works well for read-heavy workloads like user profile data Read-through Similar to Cache Aside, but the cache is always up-to-date Write-through Cache before writing to database Works well for write-heavy workloads like MMOs Write-back Similar to Write-through, but add some delay before writing to database Message queue Features: Facilitate asynchronous behaviour (background processes, tasks, batch jobs) Facilitate cross-module communication Provide temporary storage for storing messages until they’re consumed Models: Publish-subscribe (Pub-sub): one to many relationship Point to point: one to one relationship Protocols: Advanced Message Queuing Protocol (AMQP) Streaming Text Oriented Messaging Protocol (STOMP) Real life implementations LinkedIn Real-Time Architecture Facebook’s Live Streaming architecture Stream processing Layers of data processing setup: Data collection/query layer Data standardization layer Data processing layer Data analysis layer Data visualization layer Data storage layer Data security layer Ways to ingest data: Real-time Batching Challenges: Formatting, standardizing, converting data from multiple resources is a slow and tedious process It’s resource-intensive Moving data around is risky Use cases: Moving data into Hadoop Streaming data to Elastic search Log processing Real-time streaming Distributed data processing Diverge large amounts of data to several different nodes for parallel processing Popular frameworks: MapReduce - Apache Hadoop Apache Spark Apache Storm Apache Kafka Architecture Lambda leverages both real-time and batching process that consists 3 layers Batch: deals with results from the batching process Speed: gets data from the real-time streaming process Serving: combines the results from the Batch and Speed layers Kappa has only a single pipeline and only contains Speed and Serving layers Preferred if the batch and the streaming analytics results are fairly identical Real life implementations Netflix’ Keystone Real-time Stream Processing Platform Netflix’ Migrating Batch ETL to Stream Processing Other architectures Event-driven: capable of handling a big number of concurrent requests with minimal resources WebHooks: have an event-based mechanism that only fires an HTTP event to consumers whenever new info is available Share Nothing: every module has its own environment Hexagonal: Port: act as an API, interface Adapter: an implementation of the interface, convert data from Port to be consumed by Domain Domain: contain business logic Peer to Peer: nodes can communicate with each other without the need of a central server Decentralized social network","@type":"BlogPosting","@context":"https://schema.org"}</script><link rel="shortcut icon" href="/favicon.png"><link rel="alternate" type="application/atom+xml" title="Hoanh An" href="/atom.xml"><link rel="alternate" title="Hoanh An" type="application/json" href="https://hoanhan101.github.io/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style type="text/css"> body{font-family:-apple-system,BlinkMacSystemFont,'avenir next',avenir,Noto Sans,helvetica,'helvetica neue',sans-serif}h1{font-size:36px}body{font-size:1rem;line-height:1.5;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility}a,a:visited{color:inherit}a:hover,a:visited:hover{color:dodgerblue}li{list-style-position:outside;margin-left:18px;margin-bottom:2px}blockquote{background:#f9f9f9;border-left:5px solid black;font-size:100%;margin:2rem 0;padding:1rem}blockquote p{margin:0}blockquote footer{font-size:80%;margin:1rem 0 0 0}dl dt{margin-bottom:0.5rem}dl dd{font-style:italic;margin-bottom:2rem}code,.highlight{overflow:auto}code{word-break:break-all}pre{padding:1em}.date{opacity:0.6}.highlight table td{padding:5px}.highlight table pre{margin:0}.highlight .gh{color:#999999}.highlight .sr{color:#f6aa11}.highlight .go{color:#888888}.highlight .gp{color:#555555}.highlight .gu{color:#aaaaaa}.highlight .nb{color:#f6aa11}.highlight .cm{color:#75715e}.highlight .cp{color:#75715e}.highlight .c1{color:#75715e}.highlight .cs{color:#75715e}.highlight .c,.highlight .ch,.highlight .cd,.highlight .cpf{color:#75715e}.highlight .err{color:#960050}.highlight .gr{color:#960050}.highlight .gt{color:#960050}.highlight .gd{color:#49483e}.highlight .gi{color:#49483e}.highlight .ge{color:#49483e}.highlight .kc{color:#66d9ef}.highlight .kd{color:#66d9ef}.highlight .kr{color:#66d9ef}.highlight .no{color:#66d9ef}.highlight .kt{color:#66d9ef}.highlight .mf{color:#ae81ff}.highlight .mh{color:#ae81ff}.highlight .il{color:#ae81ff}.highlight .mi{color:#ae81ff}.highlight .mo{color:#ae81ff}.highlight .m,.highlight .mb,.highlight .mx{color:#ae81ff}.highlight .sc{color:#ae81ff}.highlight .se{color:#ae81ff}.highlight .ss{color:#ae81ff}.highlight .sd{color:#e6db74}.highlight .s2{color:#e6db74}.highlight .sb{color:#e6db74}.highlight .sh{color:#e6db74}.highlight .si{color:#e6db74}.highlight .sx{color:#e6db74}.highlight .s1{color:#e6db74}.highlight .s,.highlight .sa,.highlight .dl{color:#e6db74}.highlight .na{color:#a6e22e}.highlight .nc{color:#a6e22e}.highlight .nd{color:#a6e22e}.highlight .ne{color:#a6e22e}.highlight .nf,.highlight .fm{color:#a6e22e}.highlight .vc{color:#ffffff;background-color:#272822}.highlight .nn{color:#ffffff;background-color:#272822}.highlight .nl{color:#ffffff;background-color:#272822}.highlight .ni{color:#ffffff;background-color:#272822}.highlight .bp{color:#ffffff;background-color:#272822}.highlight .vg{color:#ffffff;background-color:#272822}.highlight .vi{color:#ffffff;background-color:#272822}.highlight .nv,.highlight .vm{color:#ffffff;background-color:#272822}.highlight .w{color:#ffffff;background-color:#272822}.highlight{color:#ffffff;background-color:#272822}.highlight .n,.highlight .py,.highlight .nx{color:#ffffff;background-color:#272822}.highlight .ow{color:#f92672}.highlight .nt{color:#f92672}.highlight .k,.highlight .kv{color:#f92672}.highlight .kn{color:#f92672}.highlight .kp{color:#f92672}.highlight .o{color:#f92672}hr{margin-top:20px;border:0;border-top:1px solid #eee}html{box-sizing:border-box;margin:0;padding:0}*,*:before,*:after{box-sizing:inherit}body{background-color:#edf2f7;color:#495057}header,main{margin:0 auto;max-width:50rem}main{background:white;border:2px solid #e9ecef;-webkit-box-shadow:0 0.75rem 1.5rem rgba(18,38,63,0.03);box-shadow:0 0.75rem 1.5rem rgba(18,38,63,0.03);padding:2rem 3rem}ul,ol{padding:0;list-style-position:inside}table{border-collapse:collapse;text-align:left;width:100%}table tr{border-bottom:1px solid black}table td{padding:0.5rem}img{width:100%;margin:0.5rem 0}nav ul{list-style:none !important;padding:0;text-align:center}nav ul li{display:inline-block}nav a,nav a:visited{margin:0.5rem;text-decoration:none;font-size:0.875rem;text-transform:uppercase;color:inherit}footer{margin:1rem 0;text-align:center;color:inherit}@media only screen and (max-width: 600px){nav a{margin:0}h1{font-size:26px}}</style>
    <!-- Google Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-155884327-1', 'auto');
	ga('send', 'pageview', { 'page': location.pathname + location.search + location.hash});
	ga('set', 'anonymizeIp', false);
    </script>
    <!-- End Google Analytics -->
    </head><body> <span class="over"></span><header role="banner"><nav role="navigation"><ul><li><a href="/" >Home</a></li><li><a href="/filter" >Filter</a></li><li><a href="/search">Search</a></li><li><a href="/about" >About</a></li><li><a href="https://mailchi.mp/579f9d6927dd/hoanhanco">Subscribe</a></li></ul></nav></header><main id="main" role="main"><article role="article"><h1>Modern Web Architectural Components</h1><p>A comprehensive insight into the modern web application architecture and its components, featuring scalability, database, message queue, stream processing and so on.</p><time class="date" datetime="2020-03-28T00:00:00-04:00"> March 28, 2020 &middot; 8 mins read &middot; <a class="post" href="/category/System-design-notes">System design notes</a><hr> </time><ul><li>Tiers<ul><li>A tier is a logical separation of components in an application or service - database, backend app, user interface, messaging, caching</li><li>Single tier: user interface, backend business logic, database reside in the same machine<ul><li>Pros: no network latency</li><li>Cons: hard to maintain once is shipped</li></ul></li><li>Two-tier: client (user interface, business logic) &amp; server (database)<ul><li>Communication happens over the HTTP protocol (request-response model &amp; stateless)</li><li>REST API takes advantage of the HTTP methodologies to establish communication between the client and the server</li></ul></li><li>Three-tier: user interface, application logic, database reside in different machines</li><li>N-tier: more than 3 components involved - cache, message queues, load balancers,…<ul><li>Single Responsibility Principle: a component has only a single responsibility</li><li>Separation of concerns: keep components separate, make them reusable</li></ul></li></ul></li><li>Scalability<ul><li>Ability to withstand increased workload without sacrificing the latency</li><li>Latency can be divided into 2 parts:<ul><li>Network latency: amount of time the network takes to send data packet from point A to B</li><li>Application latency: amount of time the application takes to process a user request</li></ul></li><li>Type of scalability<ul><li>Vertical scaling/scaling up: adding more power to server<ul><li>Pros: not a lot of overhead on monitoring, operating and maintaining</li><li>Cons: single point of failure</li></ul></li><li>Horizontal scaling/scaling out: adding more hardware to the existing resource pool<ul><li>Pros: cheaper, better fault-tolerance</li><li>Cons: managing server is hard, writing distributed computing program is also challenging</li></ul></li></ul></li><li>Common bottlenecks that hurt scalability<ul><li>Database latency</li><li>Poor application architecture</li><li>Not caching wisely</li><li>Inefficient configuration and load balancing</li><li>Adding business logic to the database</li><li>Badly written code</li></ul></li><li>Common strategies to improve and test the scalability<ul><li>Profiling</li><li>Cache wisely</li><li>Use a CDN</li><li>Compress data</li><li>Avoid unnecessary round trips between client and sever</li><li>Run load &amp; stress tests</li></ul></li></ul></li><li>High Availability<ul><li>Ability to stay online despite having failures at the infrastructural level in real-time</li><li>Common reasons for system failures<ul><li>Software crashes</li><li>Hardware crashes</li><li>Human error</li><li>Planned downtime</li></ul></li><li>A common way to add more availability is to have redundancy - duplicating the components &amp; keeping them on standby to take over in case the active instances go down</li></ul></li><li>Monolithic &amp; Microservices<ul><li>Monolithic: entire application code in a single service<ul><li>Pros: simple to develop, test, deploy as everything resides in one repo</li><li>Cons:<ul><li>Continuous deployment means re-deploying the entire application</li><li>Single point of failure</li><li>Hard to scale</li></ul></li></ul></li><li>Microservices: tasks are split into separate services forming a larger service as a whole<ul><li>Pros:<ul><li>No single point of failure</li><li>Easier to scale independently</li></ul></li><li>Cons:<ul><li>Difficult to manage</li><li>No strong consistency</li></ul></li></ul></li></ul></li><li>Database<ul><li>Forms of data:<ul><li>Structured: conforms to a certain structure, stored in a normalized fashion</li><li>Unstructured: no definite structure, could be text, image, video, multimedia files, machine-generated data</li><li>Semi-structured: mix of structured and unstructured data, stored in XML or JSON</li><li>User state: user logs and activity on the platform</li></ul></li><li>Why the need for NoSQL while relational database is still doing fine?<ul><li>Scaling relational database is not trivial, which requires Sharding or Replicating</li><li>NoSQL is fast with read-write and really easy to scale out</li><li>Eventual consistency over strong consistency<ul><li>Eventual consistency: achieve high availability that informally guarantees that, if no new updates are made, return the last updated value for all accesses</li><li>Strong consistency: data has to be strongly consistent at all times</li></ul></li><li>Data analytics</li></ul></li><li>Polyglot persistence<ul><li>Use different storage technologies to handle different needs within a given software application</li><li>Multi-model databases reduce the operational complexity of using several different database models in an application by supporting multiple data models via a single API</li></ul></li><li>CAP theorem<ul><li>It is impossible for a distributed data store to simultaneously provide more than two out of the following three guarantees:<ul><li>Consistency: every read receives the most recent write</li><li>Availability: every request receives a non-error response</li><li>Partition tolerance: system continues to operate despite network failures</li></ul></li></ul></li><li>Types of databases<ul><li>Document-oriented: generally semi-structured &amp; stored in a JSON-like format<ul><li>Use cases:<ul><li>Working with semi-structured data</li><li>Need a flexible schema</li><li>Examples are real-time feeds, live sport apps, web-based multiplayer games</li></ul></li><li>Real life implementations<ul><li><a href="https://www.mongodb.com/blog/post/sega-hardlight-migrates-to-mongodb-atlas-simplify-ops-improve-experience-mobile-gamers">SEGA uses Mongo-DB to simply ops and improve gaming experiences</a></li><li><a href="https://www.mongodb.com/customers/coinbase">Coinbase uses MongoDB to scale from 15k to 1.2 million requests per minute</a></li></ul></li></ul></li><li>Graph: store data in nodes/vertices and edges in the form of relationships<ul><li>Use cases:<ul><li>Maps</li><li>Social graphs</li><li>Recommendation engines</li><li>Storing genetic data</li></ul></li><li>Real life implementations<ul><li><a href="https://neo4j.com/case-studies/walmart/">Walmart uses Neo4J to show product recommendations in real-time</a></li><li><a href="https://neo4j.com/blog/david-meza-chief-knowledge-architect-nasa/">NASA uses Neo4J to store “lessons learned” data</a></li></ul></li></ul></li><li>Key-value: use a simple key-value method to store and quickly fetch the data<ul><li>Use cases:<ul><li>Caching</li><li>Implementing queue</li><li>Managing real-time data</li></ul></li><li>Real life implementations<ul><li><a href="https://redislabs.com/customers/inovonics/">Inovonics uses Redis to drive real-time analytics on millions of sensor data</a></li><li><a href="https://redislabs.com/docs/microsoft-relies-redis-labs/">Microsoft uses Redis to handle the traffic spike on its platforms</a></li><li><a href="https://cloud.google.com/appengine/docs/standard/python/memcache/">Google Cloud uses Memcache to implement caching on their cloud platform</a></li></ul></li></ul></li><li>Time series: optimized for tracking &amp; persisting time series data<ul><li>Use cases:<ul><li>Managing data in real-time &amp; continually over a long period of time</li><li>Managing data for running analytics &amp; monitoring</li></ul></li><li>Real life implementations<ul><li><a href="https://www.influxdata.com/customer/ibm/">IBM uses Influx DB to run analytics for real-time cognitive fraud detection</a></li><li><a href="https://www.influxdata.com/customer/customer_case_study_spiio/">Spiio uses Influx DB to remotely monitor vertical lining green walls &amp; plant installations</a></li></ul></li></ul></li><li>Wide Column: primarily used to handle massive amounts of data<ul><li>Use cases:<ul><li>Managing big data</li></ul></li><li>Real life implementations<ul><li><a href="https://netflixtechblog.com/tagged/cassandra">Netflix uses Cassandra as the backend database for the streaming service</a></li><li><a href="https://hbase.apache.org/poweredbyhbase.html">Adobe uses HBase for processing large amounts of data</a></li></ul></li></ul></li></ul></li></ul></li><li>Caching<ul><li>Ensure low latency and high throughput</li><li>Strategies<ul><li>Cache Aside:<ul><li>First look in the cache, return if present, else fetch from the database and update cache</li><li>Has a TTL (Time To Live) period to sync up data</li><li>Works well for read-heavy workloads like user profile data</li></ul></li><li>Read-through<ul><li>Similar to Cache Aside, but the cache is always up-to-date</li></ul></li><li>Write-through<ul><li>Cache before writing to database</li><li>Works well for write-heavy workloads like MMOs</li></ul></li><li>Write-back<ul><li>Similar to Write-through, but add some delay before writing to database</li></ul></li></ul></li></ul></li><li>Message queue<ul><li>Features:<ul><li>Facilitate asynchronous behaviour (background processes, tasks, batch jobs)</li><li>Facilitate cross-module communication</li><li>Provide temporary storage for storing messages until they’re consumed</li></ul></li><li>Models:<ul><li>Publish-subscribe (Pub-sub): one to many relationship</li><li>Point to point: one to one relationship</li></ul></li><li>Protocols:<ul><li><a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">Advanced Message Queuing Protocol (AMQP)</a></li><li><a href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">Streaming Text Oriented Messaging Protocol (STOMP)</a></li></ul></li><li>Real life implementations<ul><li><a href="https://www.8bitmen.com/linkedin-real-time-architecture-how-does-linkedin-identify-its-users-online/">LinkedIn Real-Time Architecture</a></li><li><a href="https://engineering.fb.com/ios/under-the-hood-broadcasting-live-video-to-millions/">Facebook’s Live Streaming architecture</a></li></ul></li></ul></li><li>Stream processing<ul><li>Layers of data processing setup:<ul><li>Data collection/query layer</li><li>Data standardization layer</li><li>Data processing layer</li><li>Data analysis layer</li><li>Data visualization layer</li><li>Data storage layer</li><li>Data security layer</li></ul></li><li>Ways to ingest data:<ul><li>Real-time</li><li>Batching</li></ul></li><li>Challenges:<ul><li>Formatting, standardizing, converting data from multiple resources is a slow and tedious process</li><li>It’s resource-intensive</li><li>Moving data around is risky</li></ul></li><li>Use cases:<ul><li>Moving data into Hadoop</li><li>Streaming data to Elastic search</li><li>Log processing</li><li>Real-time streaming</li></ul></li><li>Distributed data processing<ul><li>Diverge large amounts of data to several different nodes for parallel processing</li><li>Popular frameworks:<ul><li>MapReduce - Apache Hadoop</li><li>Apache Spark</li><li>Apache Storm</li><li>Apache Kafka</li></ul></li></ul></li><li>Architecture<ul><li>Lambda leverages both real-time and batching process that consists 3 layers<ul><li>Batch: deals with results from the batching process</li><li>Speed: gets data from the real-time streaming process</li><li>Serving: combines the results from the Batch and Speed layers</li></ul></li><li>Kappa has only a single pipeline and only contains Speed and Serving layers<ul><li>Preferred if the batch and the streaming analytics results are fairly identical</li></ul></li></ul></li><li>Real life implementations<ul><li><a href="https://netflixtechblog.com/keystone-real-time-stream-processing-platform-a3ee651812a">Netflix’ Keystone Real-time Stream Processing Platform</a></li><li><a href="https://netflixtechblog.com/keystone-real-time-stream-processing-platform-a3ee651812a">Netflix’ Migrating Batch ETL to Stream Processing</a></li></ul></li></ul></li><li>Other architectures<ul><li>Event-driven: capable of handling a big number of concurrent requests with minimal resources</li><li>WebHooks: have an event-based mechanism that only fires an HTTP event to consumers whenever new info is available</li><li>Share Nothing: every module has its own environment</li><li>Hexagonal:<ul><li>Port: act as an API, interface</li><li>Adapter: an implementation of the interface, convert data from Port to be consumed by Domain</li><li>Domain: contain business logic</li></ul></li><li>Peer to Peer: nodes can communicate with each other without the need of a central server</li><li>Decentralized social network</li></ul></li></ul><hr /><p><strong>References:</strong></p><ul><li><a href="https://www.educative.io/courses/web-application-software-architecture-101">https://www.educative.io/courses/web-application-software-architecture-101</a></li></ul><hr><div class="related"><h4>Interested in getting updates on my latest insights and projects, feel free to join my <a class="post" href="https://mailchi.mp/579f9d6927dd/hoanhanco">Insights mailing list</a>. Otherwise, checkout similar posts here:</h4><ul><li><a href="/db-normalization">Step by Step Database Normalization</a></li><li><a href="/design-data-intensive-apps">Designing Data-Intensive Applications by Martin Kleppmann</a></li><li><a href="/brief-history-scaling-linkedin">A Brief History of Scaling LinkedIn</a></li></ul></div><hr><p> Tagged: <a class="post" href="/tag/architecture">#architecture</a></p><br><div id="disqus_thread"></div><script> var disqus_name = "hoanhan101"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_name + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script> <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></article></main><footer class="footer" role="contentinfo"> <small> © 2020 <a style="text-decoration: none;" href="/about">Hoanh An</a> | <a style="text-decoration: none;" href="https://www.linkedin.com/in/hoanhan101/">LinkedIn</a> | <a style="text-decoration: none;" href="https://github.com/hoanhan101">GitHub</a> | <a style="text-decoration: none;" href="mailto:hoanhan101@gmail.com">Email</a> </small></footer></body></html>
